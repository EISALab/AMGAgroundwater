#ifndef __MATHBASE_H__
#define __MATHBASE_H__

#include <math.h>

#ifndef ASSERT
	#if     _MSC_VER > 1000
		#include <crtdbg.h>
		#define ASSERT _ASSERT
	#else
		#include <assert.h>
		#define ASSERT assert
	#endif
#endif

//----------------------------lib automaic include, for visual c++ only-------------------------
/*#ifdef _MSC_VER
	#ifdef _DLL
		#ifdef _DEBUG
			#pragma comment(lib, "MathSubDTD.lib")
		#else
			#pragma comment(lib, "MathSubDT.lib")
		#endif
	#else
		#ifdef _MT
			#ifdef _DEBUG
				#pragma comment(lib, "MathSubMTD.lib")
			#else
				#pragma comment(lib, "MathSubMT.lib")
			#endif	
		#else
			#ifdef _DEBUG
				#pragma comment(lib, "MathSubSTD.lib")
			#else
				#pragma comment(lib, "MathSubST.lib")
			#endif	
		#endif
	#endif
#endif*/


#define _MATHBASE_INLINE inline
#define MATH_STATIC_DATA static
/*---------------------------------------------------------------------------------------
									type definition
----------------------------------------------------------------------------------------*/
typedef double REAL;
typedef unsigned char BYTE;
typedef int BOOL;

//define data type
#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

/*---------------------------------------------------------------------------------------
									const definition
----------------------------------------------------------------------------------------*/
//*************define PI constant number
#ifndef M_PI
#define M_PI        3.14159265358979323846
#endif

#ifndef M_PI_2
#define M_PI_2      1.57079632679489661923
#endif

#ifndef M_PI_4
#define M_PI_4      0.785398163397448309616
#endif

#ifndef M_1_PI
#define M_1_PI      0.318309886183790671538
#endif

#ifndef M_2_PI
#define M_2_PI      0.636619772367581343076
#endif

#ifndef M_2_SQRTPI
#define M_2_SQRTPI	1.12837916709551257390
#endif

#ifndef M_2PI
#define M_2PI		(2*M_PI)
#endif

#ifndef PI
#define PI			M_PI
#endif


//*************define EPS constant number
#undef EPS
#undef EPS_COS
#define EPS			1e-10
#define EPS_COS     0.999999

/*---------------------------------------------------------------------------------------
									helper macros
----------------------------------------------------------------------------------------*/
#define ELEMENTS(array)		(sizeof(array)/sizeof((array)[0]))	//elements number of an arrray

//*************define min, max, MIN, MAX
#ifndef min
#define min math_min
#endif
#ifndef max
#define max math_max
#endif
#ifndef MIN
#define MIN math_min
#endif
#ifndef MAX
#define MAX math_max
#endif

//*************define SQR and sqr
#undef SQR
#undef sqr

#define SQR(x)				((x)*(x))
#define sqr					SQR

//*************define macro to convert between radius and degree
#undef D_TO_R
#undef R_TO_D
#undef D2R
#undef R2D

#define	D_TO_R(x)			((x)/180.0*M_PI)					//from degree to radian
#define R_TO_D(x)			((x)*180.0/M_PI)					//from radian to degree
#define D2R					D_TO_R
#define R2D					R_TO_D

/*---------------------------------------------------------------------------------------
									helper inline function
----------------------------------------------------------------------------------------*/
//Exchange function
template<class T>
void Exchange( T& x, T& y )
{ T t = x; x = y; y = t; }

template<class  T>
const T& math_max(const T& x, const T& y)
{ return x>y ? x : y; }

template<class T>
const T& math_min(const T& x, const T& y)
{ return x>y ? y : x; }
 
REAL math_max(REAL x1, REAL x2);
REAL math_min(REAL x1,REAL x2);

_MATHBASE_INLINE REAL math_max(REAL x1, REAL x2)
{ return (x1>x2)?x1:x2; }

_MATHBASE_INLINE REAL math_min(REAL x1,REAL x2)
{ return (x1>x2)?x2:x1; }

_MATHBASE_INLINE BOOL IsRealZero(REAL value)
{ return value+1.0==1.0; }

class ZRealMatrix;
typedef ZRealMatrix* LPREALMATRIX;
typedef const ZRealMatrix* LPCREALMATRIX;

typedef struct tagMatrixHead
{
	int nRow, nCol;
	int nAllocLen;
	int nRefs;
	LPREALMATRIX pmxLocker;
	REAL* pMatrixData;
}ZMatrixHead;

class ZRealMatrix
{
private:
	ZMatrixHead* m_pMatrixHead;
	int m_nRowBase;
	int m_nColBase;
    ZRealMatrix( const ZRealMatrix& mxInit );

protected:
	void Init();
	ZMatrixHead* GetData() const;
	REAL* GetMatrixAddr() const;
	int InternalAddRef();
	int InternalRelease();
	void AllocBuffer(int nRow, int nCol);
	void Release();

	//alloc memory for copy construction or assign copy.
	void AllocBeforeCopy(int nRow, int nCol);
	//ensure multi-referenced buffer is copied when being written
	void CopyBeforeWrite();
	//bLockBuffer is an imporant trick for reducing unnecessary buffer copy,
	//the tempory matrix generated by system should not lock the buffer,
	//the defined matrix by user should lock the buffer.
	void AssignCopy( const ZRealMatrix& mx, BOOL bLockBuffer );
	void AssignCopy( ZMatrixHead* pmxHead, BOOL bLockBuffer );

    //caculation helper function
    ZRealMatrix& Neg();
    ZRealMatrix& Add( const ZRealMatrix& mx );
    ZRealMatrix& Sub( const ZRealMatrix& mx );
    ZRealMatrix& Mul( REAL f );
	ZRealMatrix& Mul( const ZRealMatrix& mx );
	static ZRealMatrix Mul( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
	static void Mul( const ZRealMatrix& mx1, const ZRealMatrix& mx2, ZRealMatrix& mxRet );
    ZRealMatrix& Div( REAL f );
	ZRealMatrix& Pow( int k );
	static void Pow( const ZRealMatrix& mx, int k, ZRealMatrix& mxRet );
	static ZRealMatrix Pow( const ZRealMatrix& mx, int k );
	static ZRealMatrix PosPow( const ZRealMatrix& mx, int k );

//property
public:
	int Index(int nRow, int nCol) const;
	int GetRow() const;
	int GetCol() const;
	int GetSize() const;
	BOOL IsNull() const;
	void SetBaseIndex( int nRowBase=0, int nColBase=0 );
	void GetBaseIndex( int& nRowBase, int& nColBase ) const;

	REAL* GetMatrixData();
public:
// Constructors
	ZRealMatrix();						// uninitialized matrix
    ZRealMatrix( int m, int n );		// initialized matrix with random data
	ZRealMatrix( int m, int n, REAL rElement );
	ZRealMatrix( int m, int n, const REAL* prData );
	ZRealMatrix( int m, int n, const REAL** pprData );
// Destructor
    ~ZRealMatrix();

	//Initilization
	void Create( int m, int n);
	void Create( int m, int n, REAL rElement );
	void Create( int m, int n, const REAL* prData );
	void Create( int m, int n, const REAL** pprData );
    void Create( const ZRealMatrix& mxInit );

	void SetUniform( REAL rElem=0 );
	void SetIdentity();
	void SetRandom( REAL rLow=0.0, REAL rUpper=1.0 );

	void CopyBuffer( const REAL* prData, int nCount, int nOffset=0, int nSkip=0 );
	void CopyBuffer( const REAL **pprData, int m, int n, int nOffset=0, int nSkip=0 );

	void Attach( REAL *pData, int nRow, int nCol );
	REAL* Detach();

	void UnlockBuffer();
	void LockBuffer();
	LPREALMATRIX GetLocker() const;

	ZRealMatrix& Verse();
	ZRealMatrix& Invert();
	ZRealMatrix& SwapRow( int nRow1, int nRow2 );
	ZRealMatrix& SwapCol( int nCol1, int nCol2 );

	ZRealMatrix GetVerseMx() const;
	ZRealMatrix GetInvertMx() const;
	ZRealMatrix GetRowMx(int nRow) const;
	ZRealMatrix GetColMx(int nCol) const;
	ZRealMatrix GetChildMx( int nRow, int nCol, int nRowLen=-1, int nColLen=-1 ) const;
	//get the main diagonal vector, the returned matrix is (nRow, 1);
	ZRealMatrix GetDiagMx() const;
	//get the lower triangle part of matrix below the kth diagonal, k=0 is the main diagonal, 
	//k>0 is above the main diagonal, k<0 is below the main diagonal.
	ZRealMatrix GetTriLMx(int k=0) const;
	//get the upper triangle part of matrix above the kth diagonal, k=0 is the main diagonal, 
	//k>0 is above the main diagonal, k<0 is below the main diagonal.
	ZRealMatrix GetTriUMx(int k=0) const;
	//reshape matrix to a new matrix(nRow, nCol). nRow*nCol should equals GetSize();
	ZRealMatrix GetReshapeMx( int nRow, int nCol );

	void SetRowMx( const ZRealMatrix& mxRow, int nRow );
	void SetColMx( const ZRealMatrix& mxCol, int nCol );
	void SetChildMx( const ZRealMatrix& mxChd, int nRow, int nCol );


	//solve equation
	ZRealMatrix& Div( ZRealMatrix& mx );
	ZRealMatrix& RightDiv( ZRealMatrix& mx );

	//Access operator
	ZRealMatrix operator() (int i) const;		//Get a row vector
	ZRealMatrix operator[] (int i) const;		//Get a column vector
    REAL& operator () ( int i, int j );
    REAL  operator () ( int i, int j ) const;

//matrix operator
    ZRealMatrix& operator = ( const ZRealMatrix& mx );
    ZRealMatrix& operator += ( const ZRealMatrix& mx );
    ZRealMatrix& operator -= ( const ZRealMatrix& mx );
	ZRealMatrix& operator ^= ( int n );
	ZRealMatrix& operator ^= ( REAL r );
	ZRealMatrix& Add( const ZRealMatrix& mx );
	ZRealMatrix& Sub( const ZRealMatrix& mx );
	ZRealMatrix& Mul( const ZRealMatrix& mx );
	ZRealMatrix& Div( const ZRealMatrix& mx );
	ZRealMatrix& Power( int n );
	ZRealMatrix& Power( REAL r );

//matrix element operator
    ZRealMatrix& operator *= ( REAL r );
    ZRealMatrix& operator /= ( REAL r );
	ZRealMatrix& ElemAdd( REAL r );
	ZRealMatrix& ElemSub( REAL r );
	ZRealMatrix& ElemMul( REAL r );
	ZRealMatrix& ElemDiv( REAL r );
	ZRealMatrix& ElemPower( REAL r );

//get negative matrix
    ZRealMatrix operator - ();

protected:
//
// friend function
//

//matrix operator
    friend ZRealMatrix operator + ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
    friend ZRealMatrix operator - ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
    friend ZRealMatrix operator * ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
	//the same as power
	friend ZRealMatrix operator ^ ( const ZRealMatrix& mx, int n );
	friend ZRealMatrix operator ^ ( const ZRealMatrix& mx, REAL r );
	//solving the linear equation (the same definition of left divide of matlab
	friend ZRealMatrix operator / ( const ZRealMatrix& mxB, const ZRealMatrix& mxA );

	friend ZRealMatrix Power( const ZRealMatrix& mx, int n );
	friend ZRealMatrix Power( const ZRealMatrix& mx, REAL r );

//matrix element operator
	//same as ElemMul
    friend ZRealMatrix operator * ( const ZRealMatrix& mx, REAL f );
    friend ZRealMatrix operator * ( REAL f, const ZRealMatrix& mx );
	//same as ElemDiv
	friend ZRealMatrix operator / ( const ZRealMatrix& mx, REAL f );

	friend ZRealMatrix ElemAdd( const ZRealMatrix& mx, REAL r );
	friend ZRealMatrix ElemSub( const ZRealMatrix& mx, REAL r );
	friend ZRealMatrix ElemMul( const ZRealMatrix& mx, REAL r );
	friend ZRealMatrix ElemDiv( const ZRealMatrix& mx, REAL r );
	friend ZRealMatrix ElemPower( const ZRealMatrix& mx, REAL r );

};
#endif //__MATHBASE_H__