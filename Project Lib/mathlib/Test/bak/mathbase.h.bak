#ifndef __MATHBASE_H__
#define __MATHBASE_H__

#include <iostream.h>

#define _MATHBASE_INLINE inline
#define MATH_STATIC_DATA static
#define MATRIX_LOCK( mx )	((mx).LockBuffer())
/*---------------------------------------------------------------------------------------
									type definition
----------------------------------------------------------------------------------------*/
typedef double REAL;
typedef char BYTE;
typedef int BOOL;
#define TRUE	1
#define FALSE	0

/*---------------------------------------------------------------------------------------
									const definition
----------------------------------------------------------------------------------------*/
#define M_PI        3.14159265358979323846
#define M_PI_2      1.57079632679489661923
#define M_PI_4      0.785398163397448309616
#define M_1_PI      0.318309886183790671538
#define M_2_PI      0.636619772367581343076
#define M_2PI		(2*M_PI)
#define EPS			1e-10
#define EPS_COS     0.999999

#define PI			M_PI

/*---------------------------------------------------------------------------------------
									helper macros
----------------------------------------------------------------------------------------*/
#define	D_TO_R(x)			((x)/180.0*M_PI)					//from degree to radian
#define R_TO_D(x)			((x)*180.0/M_PI)					//from radian to degree
#define ELEMENTS(array)		(sizeof(array)/sizeof((array)[0]))	//elements number of an arrray
#define SQR(x)				((x)*(x))
#define sqr					SQR
#define D2R					D_TO_R
#define R2D					R_TO_D

/*---------------------------------------------------------------------------------------
									helper inline function
----------------------------------------------------------------------------------------*/
//Exchange function
template<class T>
void Exchange( T& x, T& y )
{ T t = x; x = y; y = t; }

REAL Max(REAL x1, REAL x2);
REAL Min(REAL x1,REAL x2);

_MATHBASE_INLINE REAL Max(REAL x1, REAL x2)
{ return (x1>x2)?x1:x2; }

_MATHBASE_INLINE REAL Min(REAL x1,REAL x2)
{ return (x1>x2)?x2:x1; }


class ZRealMatrix;
typedef ZRealMatrix* LPREALMATRIX;
typedef const ZRealMatrix* LPCREALMATRIX;

typedef struct tagMatrixHead
{
	int nRow, nCol;
	int nDataLen;
	int nRef;
	LPREALMATRIX pmxLocker;
	REAL* pMatrixData;
}ZMatrixHead;

class ZRealMatrix
{
private:
	ZMatrixHead* m_pMatrixHead;
	int m_nRowBase;
	int m_nColBase;
    ZRealMatrix( const ZRealMatrix& mxInit );

protected:
	void Init();
	ZMatrixHead* GetData() const;
	int InternalAddRef();
	int InternalRelease();
	void AllocBuffer(int nRow, int nCol);
	void Release();
	//bLockBuffer is an imporant trick for reducing unnecessary buffer copy,
	//the tempory matrix generated by system should not lock the buffer,
	//the defined matrix by user should lock the buffer.
	void AssignCopy( const ZRealMatrix& mx, BOOL bLockBuffer );
	void AssignCopy( ZMatrixHead* pmxHead, BOOL bLockBuffer );

    //caculation helper function
    ZRealMatrix& Neg();
    ZRealMatrix& Add( const ZRealMatrix& mx );
    ZRealMatrix& Sub( const ZRealMatrix& mx );
    ZRealMatrix& Mul( REAL f );
	ZRealMatrix& Mul( const ZRealMatrix& mx );
	ZRealMatrix Mul( const ZRealMatrix& mx1, const ZRealMatrix& mx2 ) const;
    ZRealMatrix& Div( REAL f );
	ZRealMatrix& Pow( int k );
//property
public:
	int Index(int nRow, int nCol) const;
	int GetRow() const;
	int GetCol() const;
	int GetSize() const;
	BOOL IsNull() const;
	void SetBaseIndex( int nRowBase=0, int nColBase=0 );
	void GetBaseIndex( int& nRowBase, int& nColBase ) const;

	REAL* GetMatrixData() const;
public:
// Constructors
	ZRealMatrix();						// uninitialized matrix
    ZRealMatrix( int m, int n );		// initialized matrix with random data
	ZRealMatrix( int m, int n, REAL rElement );
	ZRealMatrix( int m, int n, const REAL* prData );
	ZRealMatrix( int m, int n, const REAL** pprData );
//	ZRealMatrix( ZRealMatrix& mx ) {Init(), AssignCopy(mx.GetData(), TRUE);};
// Destructor
    ~ZRealMatrix();

	//Initilization
	void Create( int m, int n);
	void Create( int m, int n, REAL rElement );
	void Create( int m, int n, const REAL* prData );
	void Create( int m, int n, const REAL** pprData );
    void Create( const ZRealMatrix& mxInit );

	void SetUniform( REAL rElem=0 );
	void SetIdentity();

	void CopyBuffer( const REAL* prData, int nCount, int nOffset=0, int nSkip=0 );
	void CopyBuffer( const REAL **pprData, int m, int n, int nOffset=0, int nSkip=0 );

	void Attach( REAL *pData, int nRow, int nCol );
	REAL* Detach();

	void UnlockBuffer();
	void LockBuffer();
	LPREALMATRIX GetLocker() const;

	ZRealMatrix& Verse();
	ZRealMatrix& Invert();

	ZRealMatrix GetVerseMx() const;
	ZRealMatrix GetInvertMx() const;
	ZRealMatrix GetRowMx(int nRow) const;
	ZRealMatrix GetColMx(int nCol) const;
	ZRealMatrix GetChildMx( int nRow, int nCol, int nRowLen=-1, int nColLen=-1 ) const;


	ZRealMatrix& Power( int k );
	ZRealMatrix& ElemPower( REAL t );

	//Access operator
	ZRealMatrix operator() (int i) const;		//Get a row vector
	ZRealMatrix operator[] (int i) const;		//Get a column vector
    REAL& operator () ( int i, int j );
    REAL  operator () ( int i, int j ) const;

	//calculation operator
    ZRealMatrix& operator = ( const ZRealMatrix& mx );
    ZRealMatrix operator - ();
    ZRealMatrix& operator += ( const ZRealMatrix& mx );
    ZRealMatrix& operator -= ( const ZRealMatrix& mx );
    ZRealMatrix& operator *= ( REAL k );
    ZRealMatrix& operator /= ( REAL k );
	ZRealMatrix& operator ^= ( int k );
//    REAL* operator [] ( int i );
//    const REAL* operator [] ( int i ) const;
//    REAL* operator () ( int i );
//    const REAL* operator () ( int i ) const;

	void WriteData( ostream& os ) const;
	void ReadData( istream& is );

protected:
// Destructor
    //
    //
    // Member function
    //
/*    void Assign( REAL* s, int num );
    void Assign( REAL** s );
    void Clear( REAL t=0 );
*/
    //
    // friend function
    //
    friend ZRealMatrix operator + ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
    friend ZRealMatrix operator - ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
    friend ZRealMatrix operator * ( const ZRealMatrix& mx1, const ZRealMatrix& mx2 );
    friend ZRealMatrix operator * ( const ZRealMatrix& mx, REAL f );
    friend ZRealMatrix operator * ( REAL f, const ZRealMatrix& mx );
	friend ZRealMatrix operator / ( const ZRealMatrix& mx, REAL f );
	friend ZRealMatrix operator ^ ( const ZRealMatrix& mx, int t );

};

ostream& operator << ( ostream& os, ZRealMatrix& t );
istream& operator >> ( istream& is, ZRealMatrix& t );

/*------------------------------------------------------------------------*/
/*                                                                        */
/*  ZRealMatrix inlines                                                       */
/*                                                                        */
/*------------------------------------------------------------------------*/

/*_MATHBASE_INLINE ZRealMatrix ZRealMatrix::operator [] ( int i ) const
{
   return GetColMx(i);
}

_MATHBASE_INLINE ZRealMatrix ZRealMatrix::operator () ( int i ) const
{
   return GetRowMx(i);
}*/

#endif //__MATHBASE_H__